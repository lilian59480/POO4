<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ShortestPathClients.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">POO4-Project</a> &gt; <a href="index.source.html" class="el_package">algo.genetic</a> &gt; <span class="el_source">ShortestPathClients.java</span></div><h1>ShortestPathClients.java</h1><pre class="source lang-java linenums">/*
 * POO4 Project
 * Copyright (C) 2019
 * Lilian Petitpas, Thomas Ternisien, Thibaut Fenain, Corentin Apolinario
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package algo.genetic;

import algo.SolverException;
import model.Client;
import model.Depot;
import model.Emplacement;
import model.Instance;
import model.Route;

import java.util.ArrayList;
import java.util.List;

/**
 * ShortestPathClients class
 *
 * @author Thomas
 */
public class ShortestPathClients {

    /**
     * Current instance.
     */

    private Instance instance;
    /**
     * The chromosome (aka list of clients)
     */
    private Chromosome chromosome;

    /**
     * ShortestPathClients constructor, without an Instance.
     * &lt;p&gt;
     * This constructor is recommended as you can solve multiples instances by
     * using the instance setter.
     */
    public ShortestPathClients() {
<span class="nc" id="L55">        this(null);</span>
<span class="nc" id="L56">    }</span>

    /**
     * ShortestPathClients constructor, with an Instance.
     *
     * @param i Instance to solve
     */
<span class="nc" id="L63">    public ShortestPathClients(Instance i) {</span>
<span class="nc" id="L64">        this.instance = i;</span>
<span class="nc" id="L65">        this.chromosome = new Chromosome(i);</span>
<span class="nc" id="L66">    }</span>

    /**
     * ShortestPathClients constructor, with an Instance and a chromosome
     *
     * @param i          Instance to solve
     * @param chromosome the chromosome
     */
<span class="nc" id="L74">    public ShortestPathClients(Instance i, Chromosome chromosome) {</span>
<span class="nc" id="L75">        this.instance = i;</span>
<span class="nc" id="L76">        this.chromosome = chromosome;</span>
<span class="nc" id="L77">    }</span>

    /**
     * Function to ind the best Tournee using different percent
     *
     * @return the best Tournee
     * @throws SolverException SolverException If there is an internal exception
     *                         or inconsistant values.
     */
    public Tournee findBestTournee() throws SolverException {
<span class="nc" id="L87">        Tournee bestTournee = this.getBestTournee(this.findShortestPath(1), this.findShortestPath(1.5));</span>
<span class="nc" id="L88">        bestTournee = this.getBestTournee(bestTournee, this.findShortestPath(2));</span>
<span class="nc" id="L89">        bestTournee = this.getBestTournee(bestTournee, this.findShortestPath(2.5));</span>

<span class="nc" id="L91">        return this.getBestTournee(bestTournee, this.findShortestPath(10));</span>
    }
    
    /**
     * Find the best tournee of the two input tournee
     * @param tournee1 the first tournee
     * @param tournee2 the second tournee
     * @return the best tournee of the two
     */
    public Tournee getBestTournee(Tournee tournee1, Tournee tournee2) {
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (tournee1.getCost() &lt; tournee2.getCost()) {</span>
<span class="nc" id="L102">            return tournee1;</span>
        }
<span class="nc" id="L104">        return tournee2;</span>
    }

    /**
     * Funcion that calculates the shortest path in the order of clients given
     * by the chromosome
     *
     * @param percent a number to ajustate the precision
     * @return The tournee of the shortests path
     * @throws SolverException If there is an internal exception or inconsistant
     *                         values.
     */
    private Tournee findShortestPath(double percent) throws SolverException {
<span class="nc" id="L117">        List&lt;BestLabel&gt; listBestLabel = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        for (int i = 0; i &lt; this.chromosome.getClients().size(); i++) {</span>
<span class="nc" id="L119">            Chromosome partialChromosome = new Chromosome();</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">            for (int j = i; j &lt; this.chromosome.getClients().size(); j++) {</span>
<span class="nc" id="L121">                Client client = this.chromosome.getClients().get(j);</span>
<span class="nc" id="L122">                partialChromosome.getClients().add(client);</span>
<span class="nc" id="L123">                Label label = this.findPartialShortestPath(partialChromosome);</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                if (label != null) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                    if (listBestLabel.size() &gt;= j + 1) {</span>
<span class="nc" id="L126">                        BestLabel newLabel = new BestLabel(label, listBestLabel.get(i - 1));</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">                        if (this.shouldReplaceCurrentLabel(listBestLabel.get(j), newLabel, percent)) {</span>
<span class="nc" id="L128">                            listBestLabel.set(j, newLabel);</span>
                        }
<span class="nc" id="L130">                    } else {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                        if (i == 0) {</span>
<span class="nc" id="L132">                            listBestLabel.add(new BestLabel(label));</span>
                        } else {
<span class="nc" id="L134">                            listBestLabel.add(new BestLabel(label, listBestLabel.get(i - 1)));</span>
                        }
                    }
                } else {
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    if (i == j) {</span>
<span class="nc" id="L139">                        throw new SolverException(</span>
<span class="nc" id="L140">                                &quot;Error cannot find route between &quot; + client.toString() + &quot; and depot&quot;);</span>
                    } else {
                        break;
                    }
                }
            }
        }

<span class="nc" id="L148">        return new Tournee(listBestLabel.get(listBestLabel.size() - 1), this.instance.getNbVehicules(), this.instance.getCoutVehicule());</span>
    }

    /**
     * Function that checks whether we should replace the current BestLabel
     *
     * @param currentLabel the current label
     * @param newLabel     the new label
     * @param percent      a number to ajustate the precision
     * @return whether we should replace it or not
     */
    private boolean shouldReplaceCurrentLabel(BestLabel currentLabel, BestLabel newLabel, double percent) {
<span class="nc bnc" id="L160" title="All 4 branches missed.">        if (newLabel.getLabelsPre().size() &lt; currentLabel.getLabelsPre().size() &amp;&amp; newLabel.getCost() &lt;= (currentLabel.getCost() * percent)) {</span>
            //Should be unreachable
<span class="nc" id="L162">            return true;</span>
        }
<span class="nc bnc" id="L164" title="All 4 branches missed.">        if (newLabel.getLabelsPre().size() == currentLabel.getLabelsPre().size() &amp;&amp; newLabel.getCost() &lt; currentLabel.getCost()) {</span>
<span class="nc" id="L165">            return true;</span>
        }
<span class="nc bnc" id="L167" title="All 2 branches missed.">        return (newLabel.getCost() * percent) &lt; currentLabel.getCost();</span>
    }

    /**
     * Funcion that tries to find the shortest path going throught every clients
     * if that path exists
     *
     * @param partialChromosome the partial chromosome
     * @return A label if there is path path, null otherwise
     */
    private Label findPartialShortestPath(Chromosome partialChromosome) {
<span class="nc" id="L178">        Depot depot = this.instance.getDepot();</span>
<span class="nc" id="L179">        int closeTime = depot.getHeureFin();</span>
<span class="nc" id="L180">        List&lt;ClientLabels&gt; labelsEC = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (int i = 0; i &lt; partialChromosome.getClients().size(); i++) {</span>
<span class="nc" id="L182">            Client client = partialChromosome.getClients().get(i);</span>
<span class="nc" id="L183">            labelsEC.add(new ClientLabels(i));</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            for (Emplacement em : client.getEmplacements()) {</span>
                //Add label to for depot
<span class="nc" id="L186">                Route r2dest = em.getRouteTo(depot);</span>
<span class="nc" id="L187">                Route r2dep = depot.getRouteTo(em);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                if (i == 0) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                    if (Math.max(r2dest.getTemps(), em.getHeureDebut()) &lt;= em.getHeureFin()) {</span>
<span class="nc" id="L190">                        int newTime = Math.max(r2dest.getTemps(), em.getHeureDebut()) + r2dep.getTemps();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                        if (newTime &lt;= closeTime) {</span>
<span class="nc" id="L192">                            labelsEC.get(i).addLabel(new Label(</span>
<span class="nc" id="L193">                                    client.getDemande(),</span>
<span class="nc" id="L194">                                    r2dest.getCout() + r2dep.getCout(),</span>
                                    newTime,
                                    em,
                                    depot
                            ));
                        }
<span class="nc" id="L200">                    }</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                } else if (i &gt; 0) { //etend les labels precedents</span>
<span class="nc" id="L202">                    this.extendsPreviousLabels(em, labelsEC.get(i - 1), labelsEC.get(i));</span>
                }
<span class="nc" id="L204">            }</span>
        }
<span class="nc" id="L206">        return this.getBestLabelFromClientLabels(labelsEC.get(labelsEC.size() - 1));</span>
    }

    /**
     * Functions that extends the previous labels
     *
     * @param em                   the emplacement you want to extends labels to
     * @param previousClientLabels the previous ClientLabels (where there are
     *                             the labels to extends)
     * @param clientLabels         the ClientLabels in which you want to put the
     *                             extended labels
     */
    private void extendsPreviousLabels(Emplacement em, ClientLabels previousClientLabels, ClientLabels clientLabels) {
<span class="nc" id="L219">        int capaV = this.instance.getCapaciteVehicule();</span>
<span class="nc" id="L220">        Depot depot = this.instance.getDepot();</span>
<span class="nc" id="L221">        int closeTime = depot.getHeureFin();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        for (Label labelPre : previousClientLabels.getLabels()) {</span>
<span class="nc" id="L223">            Emplacement precedantEm = labelPre.getEmplacement();</span>
<span class="nc" id="L224">            Route r0 = precedantEm.getRouteTo(depot);</span>
<span class="nc" id="L225">            Route r1 = precedantEm.getRouteTo(em);</span>
<span class="nc" id="L226">            Route r2 = em.getRouteTo(depot);</span>
<span class="nc" id="L227">            int arrivalTime = Math.max(labelPre.getTime() - r0.getTemps() + r1.getTemps(), em.getHeureDebut());</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            if (arrivalTime &lt;= em.getHeureFin()) {</span>
<span class="nc" id="L229">                int newLoad = labelPre.getLoad() + em.getClient().getDemande();</span>
<span class="nc" id="L230">                int newTime = arrivalTime + r2.getTemps();</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">                if (newLoad &lt;= capaV &amp;&amp; newTime &lt;= closeTime) {</span>
<span class="nc" id="L232">                    Label newLabel = new Label(</span>
                            newLoad,
<span class="nc" id="L234">                            labelPre.getCost() - r0.getCout() + r1.getCout() + r2.getCout(),</span>
                            newTime,
                            em,
<span class="nc" id="L237">                            labelPre.getPrecedents()</span>
                    );
<span class="nc" id="L239">                    newLabel.addPrecedent(precedantEm);</span>
<span class="nc" id="L240">                    clientLabels.addLabel(newLabel);</span>
<span class="nc" id="L241">                    labelPre.addSuivant(em);</span>
                }
            }
<span class="nc" id="L244">        }</span>
<span class="nc" id="L245">    }</span>

    /**
     * Function that retrieve the best Label from a ClientLabels
     *
     * @param cl the ClientLabels
     * @return the best Label
     */
    private Label getBestLabelFromClientLabels(ClientLabels cl) {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (cl.getLabels().size() == 0) {</span>
<span class="nc" id="L255">            return null;</span>
        }
<span class="nc" id="L257">        Label bestLabel = cl.getLabels().get(0);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for (int i = 1; i &lt; cl.getLabels().size(); i++) {</span>
<span class="nc" id="L259">            Label tempLabel = cl.getLabels().get(i);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (bestLabel.getCost() &gt; tempLabel.getCost()) {</span>
<span class="nc" id="L261">                bestLabel = tempLabel;</span>
<span class="nc bnc" id="L262" title="All 4 branches missed.">            } else if (bestLabel.getCost() == tempLabel.getCost() &amp;&amp; bestLabel.getTime() &gt; tempLabel.getTime()) {</span>
<span class="nc" id="L263">                bestLabel = tempLabel;</span>
            }
        }
<span class="nc" id="L266">        return bestLabel;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>